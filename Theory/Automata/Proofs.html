
				
				<html>
					<head>
						<meta charset="UTF-8"/>
						<meta name="viewport" content="width=device-width, initial-scale=1"/>
						<style>.jsdraw--editButton {
  display: none;
  width: min-content;
  max-height: 50px;
  z-index: 1;
  opacity: 0.9;
  align-self: flex-end;
  justify-self: right;
}

.jsdraw--svgWrapper {
  display: inline-grid;
}

.jsdraw--svgWrapper > * {
  grid-row: 1;
  grid-column: 1;
}

.jsdraw--svgWrapper:hover .jsdraw--editButton,
.jsdraw--svgWrapper:focus .jsdraw--editButton,
.jsdraw--svgWrapper:focus-within .jsdraw--editButton,
.jsdraw--editButton:focus {
  display: block;
}</style><script>(()=>{"use strict";var t={167:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=t=>{const e=t.querySelector("img");if(!e)return void console.warn("Freehand drawing plugin: No image found in container.");if(t.classList.contains("js-draw--editable"))return;t.classList.add("js-draw--editable");const n=t.getAttribute("data-js-draw-edit-label"),o=t.getAttribute("data-js-draw-content-script-id"),s=()=>{const t=e.src;webviewApi.postMessage(o,t).catch((e=>{console.error("Error posting message!",e,"\nMessage: ",t)}))};document.body.classList.contains("mce-content-body")||"tinymce"===document.body.id?e.style.cursor="pointer":(()=>{const e=document.createElement("button");e.textContent=`${n} üñäÔ∏è`,e.classList.add("jsdraw--editButton"),t.appendChild(e),e.onclick=()=>{s()}})(),e.ondblclick=s}}},e={};function n(o){var s=e[o];if(void 0!==s)return s.exports;var r=e[o]={exports:{}};return t[o](r,r.exports,n),r.exports}(()=>{const t=n(167),e=()=>{const e=document.querySelectorAll("*[data-js-draw-content-script-id]");for(const n of e)(0,t.default)(n)};document.addEventListener("joplin-noteDidUpdate",(()=>{e()})),e()})()})();</script></script><style>pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1em;
}

code.hljs {
  padding: 3px 5px;
}

/*

Atom One Light by Daniel Gamage
Original One Light Syntax theme from https://github.com/atom/one-light-syntax

base:    #fafafa
mono-1:  #383a42
mono-2:  #686b77
mono-3:  #a0a1a7
hue-1:   #0184bb
hue-2:   #4078f2
hue-3:   #a626a4
hue-4:   #50a14f
hue-5:   #e45649
hue-5-2: #c91243
hue-6:   #986801
hue-6-2: #c18401

*/

.hljs {
  color: #383a42;
  background: #fafafa;
}

.hljs-comment,
.hljs-quote {
  color: #a0a1a7;
  font-style: italic;
}

.hljs-doctag,
.hljs-keyword,
.hljs-formula {
  color: #a626a4;
}

.hljs-section,
.hljs-name,
.hljs-selector-tag,
.hljs-deletion,
.hljs-subst {
  color: #e45649;
}

.hljs-literal {
  color: #0184bb;
}

.hljs-string,
.hljs-regexp,
.hljs-addition,
.hljs-attribute,
.hljs-meta .hljs-string {
  color: #50a14f;
}

.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-type,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-number {
  color: #986801;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link,
.hljs-meta,
.hljs-selector-id,
.hljs-title {
  color: #4078f2;
}

.hljs-built_in,
.hljs-title.class_,
.hljs-class .hljs-title {
  color: #c18401;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-link {
  text-decoration: underline;
}</style>
						<title>Proofs</title>
					</head>
					<body>
						<div class="exported-note"><div class="exported-note-title">Proofs</div>

<style>
		/* https://necolas.github.io/normalize.css/ */
		html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}
		article,aside,footer,header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}
		pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}
		b,strong{font-weight:bolder}small{font-size:80%}img{border-style:none}

		body {
			font-size: 15px;
			color: #32373F;
			word-wrap: break-word;
			line-height: 1.6em;
			background-color: #ffffff;
			font-family: 'Avenir Next', 'Avenir', 'Arial', sans-serif;
			padding-bottom: 0px;
			padding-top: 0px;
		}
		kbd {
			border: 1px solid rgb(220, 220, 220);
			box-shadow: inset 0 -1px 0 rgb(220, 220, 220);
			padding: 2px 4px;
			border-radius: 3px;
			background-color: rgb(243, 243, 243);
		}

		:root {
			--scrollbar-size: 7px;
		}

		::-webkit-scrollbar {
			width: var(--scrollbar-size);
			height: var(--scrollbar-size);
		}
		::-webkit-scrollbar-thumb {
			border-radius: calc(var(--scrollbar-size) / 2);
		}
		::-webkit-scrollbar-corner {
			background: none;
		}
		::-webkit-scrollbar-track {
			border: none;
		}
		::-webkit-scrollbar-thumb {
			background: rgba(50, 55, 63, 0.54); 
		}
		::-webkit-scrollbar-track:hover {
			background: rgba(0, 0, 0, 0.1); 
		}
		::-webkit-scrollbar-thumb:hover {
			background: rgba(50, 55, 63, 0.63); 
		}

		

		/* Remove top padding and margin from first child so that top of rendered text is aligned to top of text editor text */

		#rendered-md > h1:first-child,
		#rendered-md > h2:first-child,
		#rendered-md > h3:first-child,
		#rendered-md > h4:first-child,
		#rendered-md > ul:first-child,
		#rendered-md > ol:first-child,
		#rendered-md > table:first-child,
		#rendered-md > blockquote:first-child,
		#rendered-md > img:first-child,
		#rendered-md > p:first-child {
			margin-top: 0;
			padding-top: 0;
		}
		
		p, h1, h2, h3, h4, h5, h6, ul, table {
			margin-top: .6em;
			margin-bottom: 1.35em;

			/*
				Adds support for RTL text in the note body. It automatically detects the direction using the content.
				Issue: https://github.com/laurent22/joplin/issues/3991
			*/
			unicode-bidi: plaintext;
		}

		h1, h2, h3, h4, h5, h6, ul, table {
			margin-bottom: 0.65em;
		}

		h1, h2, h3, h4, h5, h6 {
			line-height: 1.5em;
		}
		h1 {
			font-size: 1.5em;
			font-weight: bold;
			border-bottom: 1px solid #dddddd;
			padding-bottom: .3em;
		}
		h2 {
			font-size: 1.3em;
			font-weight: bold;
			padding-bottom: .1em; */
		}
		h3 {
			font-size: 1.1em;
			font-weight: bold;
		}
		h4, h5, h6 {
			font-size: 1em;
			font-weight: bold;
		}

		.exported-note-title {
			font-size: 2em;
			font-weight: bold;
			margin-bottom: 0.8em;
			line-height: 1.5em;
			padding-bottom: .35em;
			border-bottom: 1px solid #dddddd;
		}

		a {
			color: #155BDA;
		}
		ul, ol {
			padding-left: 0;
			margin-left: 1.7em;
		}
		li {
			margin-bottom: .4em;
		}
		li p {
			margin-top: 0.2em;
			margin-bottom: 0;
		}

		dt {
			font-weight: bold;
			margin-bottom: 0.25em;
		}

		dd {
			margin-inline-start: 2.5em;
			margin-bottom: 0.5em;
		}

		.resource-icon {
			display: inline-block;
			position: relative;
			top: 0.3em;
			text-decoration: none;
			width: 1.2em;
			height: 1.4em;
			margin-right: 0.4em;
			background-color:  #155BDA;
		}
    /* These icons are obtained from the wonderful ForkAwesome project by copying the src svgs 
     * into the css classes below.
     * svgs are obtained from https://github.com/ForkAwesome/Fork-Awesome/tree/master/src/icons/svg
     * instead of the svg width, height property you must use a viewbox here, 0 0 1536 1792 is typically the actual size of the icon
     * each line begins with the pre-amble -webkit-mask: url("data:image/svg+xml;utf8,
     * and of course finishes with ");
     * to prevent artifacts it is also necessary to include -webkit-mask-repeat: no-repeat;
     * on the following line
     * */
		.fa-joplin {
			/* Awesome Font file */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M373.834 128C168.227 128 0 296.223 0 501.834v788.336C0 1495.778 168.227 1664 373.834 1664h788.336c205.608 0 373.83-168.222 373.83-373.83V501.834C1536 296.224 1367.778 128 1162.17 128zm397.222 205.431h417.424a7.132 7.132 0 0 1 7.132 7.133v132.552c0 4.461-3.619 8.073-8.077 8.073h-57.23c-24.168 0-43.768 19.338-44.284 43.374v2.377h-.017v136.191h-.053l-.466 509.375c-5.02 77.667-39.222 149.056-96.324 201.046-60.28 54.834-141.948 85.017-229.962 85.017-12.45 0-25.208-.61-37.907-1.785-92.157-8.682-181.494-48.601-251.662-112.438-71.99-65.517-117.147-150.03-127.164-238-11.226-98.763 23.42-192.783 95.045-257.937 81.99-74.637 198.185-101.768 316.613-75.704 5.574 1.227 9.55 6.282 9.55 11.997v199.52c-.199 2.625-1.481 6.599-8.183 2.896-.663-.365-1.194-.511-1.653-.531-21.987-10.587-45.159-17.57-68.559-19.916-.38-.04-.757-.124-1.138-.163-.537-.048-1.034-.033-1.556-.075-4.13-.354-8.183-.517-12.203-.58-.87-.011-1.771-.127-2.641-.127-.486 0-.951.05-1.437.057-1.464.011-2.886.115-4.33.163-2.76.102-5.497.211-8.182.448-.273.024-.547.07-.835.097-25.509 2.4-47.864 11.104-65.012 25.47-.954.802-1.974 1.53-2.9 2.36a1.34 1.34 0 0 1-.168.146c-23.96 21.8-34.881 53.872-30.726 90.316 4.62 40.737 26.94 81.156 62.841 113.823 35.908 32.67 80.335 52.977 125.113 57.186 35.118 3.36 66.547-3.919 89.899-20.461a97.255 97.255 0 0 0 9.365-7.501c2.925-2.661 5.569-5.5 8.086-8.416.3-.348.672-.673.975-1.024 8.253-9.864 14.222-21.067 17.996-33.148.639-2.034 1.051-4.148 1.564-6.227.381-1.563.81-3.106 1.112-4.693.555-2.784.923-5.632 1.253-8.49.086-.709.183-1.414.237-2.128.492-4.893.693-9.858.55-14.91h.013V521.623c-2.01-22.626-20.78-40.434-43.928-40.434h-57.23a8.071 8.071 0 0 1-8.077-8.073V340.564a7.132 7.132 0 0 1 7.136-7.133z'/></svg>");
		}
		.fa-file-image {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-128-448v320H256v-192l192-192 128 128 384-384zm-832-192c-106 0-192-86-192-192s86-192 192-192 192 86 192 192-86 192-192 192z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-pdf {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-514-593c25 20 53 38 84 56 42-5 81-7 117-7 67 0 152 8 177 49 7 10 13 28 2 52-1 1-2 3-3 4v1c-3 18-18 38-71 38-64 0-161-29-245-73-139 15-285 46-392 83-103 176-182 262-242 262-10 0-19-2-28-7l-24-12c-3-1-4-3-6-5-5-5-9-16-6-36 10-46 64-123 188-188 8-5 18-2 23 6 1 1 2 3 2 4 31-51 67-116 107-197 45-90 80-178 104-262-32-109-42-221-24-287 7-25 22-40 42-40h22c15 0 27 5 35 15 12 14 15 36 9 68-1 3-2 6-4 8 1 3 1 5 1 8v30c-1 63-2 123-14 192 35 105 87 190 146 238zm-576 411c30-14 73-57 137-158-75 58-122 124-137 158zm398-920c-10 28-10 76-2 132 3-16 5-31 7-44 2-17 5-31 7-43 1-3 2-5 4-8-1-1-1-3-2-5-1-18-7-29-13-36 0 2-1 3-1 4zm-124 661c88-35 186-63 284-81-10-8-20-15-29-23-49-43-93-103-127-176-19 61-47 126-83 197-15 28-30 56-45 83zm646-16c-5-5-31-24-140-24 49 18 94 28 124 28 9 0 14 0 18-1 0-1-1-2-2-3z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-word {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM233 768v107h70l164 661h159l128-485c5-15 8-30 10-46 1-8 2-16 2-24h4l3 24c3 14 4 30 9 46l128 485h159l164-661h70V768h-300v107h90l-99 438c-4 16-6 33-7 46l-2 21h-4c0-6-2-14-3-21-3-13-5-30-9-46L825 768H711l-144 545c-4 16-5 33-8 46l-4 21h-4l-2-21c-1-13-3-30-7-46l-99-438h90V768H233z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-powerpoint {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-992-234v106h327v-106h-93v-167h137c43 0 82-2 118-15 90-31 146-124 146-233s-54-193-137-228c-38-15-84-19-130-19H416v107h92v555h-92zm353-280H650V882h120c35 0 62 6 83 18 36 21 56 62 56 115 0 56-20 99-62 120-21 10-47 15-78 15z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-excel {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zm-979-234v106h281v-106h-75l103-161c12-19 18-34 21-34h2c1 4 3 7 5 10 4 8 10 14 17 24l107 161h-76v106h291v-106h-68l-192-273 195-282h67V768H828v107h74l-103 159c-12 19-21 34-21 33h-2c-1-4-3-7-5-10-4-7-9-14-17-23L648 875h76V768H434v107h68l189 272-194 283h-68z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-audio {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM620 850c12 5 20 17 20 30v544c0 13-8 25-20 30-4 1-8 2-12 2-8 0-16-3-23-9l-166-167H288c-18 0-32-14-32-32v-192c0-18 14-32 32-32h131l166-167c10-9 23-12 35-7zm417 689c19 0 37-8 50-24 83-102 129-231 129-363s-46-261-129-363c-22-28-63-32-90-10-28 23-32 63-9 91 65 80 100 178 100 282s-35 202-100 282c-23 28-19 68 9 90 12 10 26 15 40 15zm-211-148c17 0 34-7 47-20 56-60 87-137 87-219s-31-159-87-219c-24-26-65-27-91-3-25 24-27 65-2 91 33 36 52 82 52 131s-19 95-52 131c-25 26-23 67 2 91 13 11 29 17 44 17z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-video {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM768 768c70 0 128 58 128 128v384c0 70-58 128-128 128H384c-70 0-128-58-128-128V896c0-70 58-128 128-128h384zm492 2c12 5 20 17 20 30v576c0 13-8 25-20 30-4 1-8 2-12 2-8 0-17-3-23-9l-265-266v-90l265-266c6-6 15-9 23-9 4 0 8 1 12 2z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-archive {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M640 384V256H512v128h128zm128 128V384H640v128h128zM640 640V512H512v128h128zm128 128V640H640v128h128zm700-388c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H768v128H640V128H128v1536h1280zM781 943c85 287 107 349 107 349 5 17 8 34 8 52 0 111-108 192-256 192s-256-81-256-192c0-18 3-35 8-52 0 0 21-62 120-396V768h128v128h79c29 0 54 19 62 47zm-141 465c71 0 128-29 128-64s-57-64-128-64-128 29-128 64 57 64 128 64z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-code {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM480 768c11-14 31-17 45-6l51 38c14 11 17 31 6 45l-182 243 182 243c11 14 8 34-6 45l-51 38c-14 11-34 8-45-6l-226-301c-8-11-8-27 0-38zm802 301c8 11 8 27 0 38l-226 301c-11 14-31 17-45 6l-51-38c-14-11-17-31-6-45l182-243-182-243c-11-14-8-34 6-45l51-38c14-11 34-8 45 6zm-620 461c-18-3-29-20-26-37l138-831c3-18 20-29 37-26l63 10c18 3 29 20 26 37l-138 831c-3 18-20 29-37 26z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file-alt, .fa-file-csv {
      /* fork-awesome doesn't have csv so we use the text icon */
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280zM384 800c0-18 14-32 32-32h704c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64zm736 224c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704zm0 256c18 0 32 14 32 32v64c0 18-14 32-32 32H416c-18 0-32-14-32-32v-64c0-18 14-32 32-32h704z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		.fa-file {
			-webkit-mask: url("data:image/svg+xml;utf8,<svg viewBox='0 0 1536 1792' xmlns='http://www.w3.org/2000/svg'><path d='M1468 380c37 37 68 111 68 164v1152c0 53-43 96-96 96H96c-53 0-96-43-96-96V96C0 43 43 0 96 0h896c53 0 127 31 164 68zm-444-244v376h376c-6-17-15-34-22-41l-313-313c-7-7-24-16-41-22zm384 1528V640H992c-53 0-96-43-96-96V128H128v1536h1280z'/></svg>");
      -webkit-mask-repeat: no-repeat;
		}
		blockquote {
			border-left: 4px solid rgb(220, 220, 220);
			padding-left: 1.2em;
			margin-left: 0;
			opacity: 0.7;
		}

		.jop-tinymce table,
		table {
			text-align: left;
			border-collapse: collapse;
			border: 1px solid rgb(220, 220, 220);
			background-color: #ffffff;
		}

		.jop-tinymce table td, .jop-tinymce table th,
		table td, th {
			text-align: left;
			padding: .5em 1em .5em 1em;
			font-size: 15;
			color: #32373F;
			font-family: 'Avenir Next', 'Avenir', 'Arial', sans-serif;
		}

		.jop-tinymce table td,
		table td {
			border: 1px solid rgb(220, 220, 220);
		}

		.jop-tinymce table th,
		table th {
			border: 1px solid rgb(220, 220, 220);
			border-bottom: 2px solid rgb(220, 220, 220);
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:nth-child(even),
		table tr:nth-child(even) {
			background-color: rgb(247, 247, 247);
		}

		.jop-tinymce table tr:hover,
		table tr:hover {
			background-color: #e5e5e5;
		}

		hr {
			border: none;
			border-bottom: 2px solid #dddddd;
		}
		img {
			max-width: 100%;
			height: auto;
		}
		
		.inline-code,
		.mce-content-body code {
			border: 1px solid rgb(220, 220, 220);
			background-color: rgb(243, 243, 243);
			padding-right: .2em;
			padding-left: .2em;
			border-radius: .25em;
			color: rgb(0,0,0);
			font-size: .9em;
		}

		.highlighted-keyword {
			background-color: #F3B717;
			color: black;
		}

		
	.not-loaded-resource img {
		width: 1.15em;
		height: 1.15em;
		background: white;
		padding: 2px !important;
		border-radius: 2px;
		box-shadow: 0 1px 3px #000000aa;
	}

	a.not-loaded-resource img {
		margin-right: .2em;
	}

	a.not-loaded-resource {
		display: flex;
		flex-direction: row;
		align-items: center;
	}


		.md-checkbox input[type=checkbox]:checked {
			opacity: 0.7;
		}

		.jop-tinymce ul.joplin-checklist .checked,
		.md-checkbox .checkbox-label-checked {
			opacity: 0.5;
		}

		.exported-note {
			padding: 1em;
		}

		.joplin-editable .joplin-source {
			display: none;
		}

		mark {
			background: #F7D26E;
			color: black;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		.mce-content-body {
			/* Note: we give a bit more padding at the bottom, to allow scrolling past the end of the document */
			padding: 5px 10px 10em 0;
		}

		/*
		.mce-content-body code {
			background-color: transparent;
		}
		*/

		.mce-content-body [data-mce-selected=inline-boundary] {
			background-color: transparent;
		}

		.mce-content-body .joplin-editable {
			cursor: pointer !important;
		}

		.mce-content-body.mce-content-readonly {
			opacity: 0.5;
		}

		/* We need that to make sure click events have the A has a target */
		.katex a span {
			pointer-events: none;
		}

		.media-player {
			width: 100%;
			margin-top: 10px;
		}

		.media-player.media-pdf {
			min-height: 35rem;
			width: 100%;
			max-width: 1000px;
			margin: 0;
			border: 0;
			display: block;
		}

		/* Clear the CODE style if the element is within a joplin-editable block */
		.mce-content-body .joplin-editable code {
			border: none;
			background: none;
			padding: 0;
			color: inherit;
			font-size: inherit;
		}

		/* To make code blocks horizontally scrollable */
		/* https://github.com/laurent22/joplin/issues/5740 */
		pre.hljs {
			overflow-x: auto;
		}

		.joplin-table-wrapper{
			overflow-x: auto;
			overflow-y: hidden;
		}

		/* =============================================== */
		/* For TinyMCE */
		/* =============================================== */

		@media print {
			body {
				height: auto !important;
			}

			pre {
				white-space: pre-wrap;
			}

			.code, .inline-code {
				border: 1px solid #CBCBCB;
			}

			#joplin-container-content {
				/* The height of the content is set dynamically by JavaScript (in updateBodyHeight) to go
				   around various issues related to scrolling. However when printing we don't want this
				   fixed size as that would crop the content. So we set it to auto here. "important" is
				   needed to override the style set by JavaScript at the element-level. */
				height: auto !important;
			}
		}
	

				/*
					FOR THE MARKDOWN EDITOR
				*/

				/* Remove the indentation from the checkboxes at the root of the document
				   (otherwise they are too far right), but keep it for their children to allow
				   nested lists. Make sure this value matches the UL margin. */

				li.md-checkbox {
					list-style-type: none;
				}

				li.md-checkbox input[type=checkbox] {
					margin-left: -1.71em;
					margin-right: 0.7em;
					position: relative;
					top: 1px;
				}
				
				ul.joplin-checklist {
					list-style:none;
				}

				/*
					FOR THE RICH TEXT EDITOR
				*/

				ul.joplin-checklist li::before {
					content:"\f14a";
					font-family:"Font Awesome 5 Free";
					background-size: 16px 16px;
					pointer-events: all;
					cursor: pointer;
					width: 1em;
					height: 1em;
					margin-left: -1.3em;
					position: absolute;
					color: #32373F;
				}

				.joplin-checklist li:not(.checked)::before {
					content:"\f0c8";
				}
.mermaid { width: 640px; }
pre.mermaid[data-processed=true] { white-space: unset; }
.mermaid-export-graph {
					opacity: 0;
					height: 0;
					z-index: 1;
					position: relative;
				} 
				.joplin-editable:hover .mermaid-export-graph,
				.joplin-editable .mermaid-export-graph:has(:focus-visible) {
					opacity: 1;
				}
				.mermaid-export-graph > button:hover {
					background-color: #CBDAF1 !important;
				}</style><div id="rendered-md"><h1 id="detailed-proofs-kleenes-theorem-pumping-lemmas-key-theorems">Detailed Proofs - Kleene&apos;s Theorem, Pumping Lemmas &amp; Key Theorems</h1>
<h2 id="brain-proof-ideas-summary"><strong>üß† Proof Ideas Summary</strong></h2>
<h3 id="core-proof-techniques-in-automata-theory"><strong>Core Proof Techniques in Automata Theory:</strong></h3>
<ol>
<li><strong>State Elimination (Kleene Part 1)</strong> - Systematically remove states while preserving language, building up regex complexity</li>
<li><strong>Inductive Construction (Kleene Part 2)</strong> - Build NFAs for complex expressions from simple base cases</li>
<li><strong>Pigeonhole Principle (Pumping Lemmas)</strong> - Force repetition in finite structures to create &quot;pumpable&quot; segments</li>
<li><strong>Diagonalization (Halting Problem)</strong> - Self-reference paradox to prove undecidability</li>
<li><strong>Reduction (Rice&apos;s Theorem)</strong> - Transform one problem into another to transfer (un)decidability</li>
<li><strong>Constructive Proof (Union, Arden)</strong> - Explicitly build the desired object (grammar, regex, automaton)</li>
<li><strong>Simulation (TM Equivalence)</strong> - Show how one model can mimic another with encoding tricks</li>
</ol>
<h3 id="key-insight-patterns"><strong>Key Insight Patterns:</strong></h3>
<ul>
<li><strong>Finite vs Infinite:</strong> Use finiteness to force repetition (pumping)</li>
<li><strong>Equivalence Proofs:</strong> Build bijections between different representations</li>
<li><strong>Undecidability:</strong> Self-reference creates paradoxes</li>
<li><strong>Closure:</strong> Combine existing objects to create new ones with desired properties</li>
</ul>
<hr/>
<h2 id="kleenes-theorem-part-1"><strong>Kleene&apos;s Theorem - Part 1</strong></h2>
<p><strong>Statement:</strong> If a language L is accepted by a finite automaton, then L can be described by a regular expression.</p>
<h3 id="bulb-proof-idea"><strong>üí° Proof Idea:</strong></h3>
<p>The key insight is to systematically eliminate states from the automaton while keeping track of all possible paths using regular expressions. Each eliminated state is &quot;absorbed&quot; into the transitions between remaining states.</p>
<h3 id="proof-state-elimination-method"><strong>Proof (State Elimination Method):</strong></h3>
<p><strong>Step 1:</strong> Convert the given DFA/NFA to a Generalized NFA (GNFA) where:</p>
<ul>
<li>Transitions are labeled with regular expressions (not just symbols)</li>
<li>Exactly one start state with no incoming edges</li>
<li>Exactly one accept state with no outgoing edges</li>
<li>At most one transition between any two states</li>
</ul>
<p><strong>Step 2:</strong> Systematically eliminate states (except start and accept states):</p>
<p>For each state q to be eliminated:</p>
<ol>
<li>For every pair of states (qi, qj) where qi &rarr; q &rarr; qj:</li>
<li>Add/modify transition qi &rarr; qj with label: R‚ÇÅ(R‚ÇÇ)*R‚ÇÉ
<ul>
<li>R‚ÇÅ = regex from qi to q</li>
<li>R‚ÇÇ = regex from q to q (self-loop)</li>
<li>R‚ÇÉ = regex from q to qj</li>
</ul>
</li>
</ol>
<p><strong>Step 3:</strong> Continue until only start and accept states remain.</p>
<p><strong>Step 4:</strong> The regular expression on the final transition is the answer.</p>
<p><strong>Example:</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```
" data-joplin-source-close="
```">DFA: States {q‚ÇÄ, q‚ÇÅ}, q‚ÇÄ start, q‚ÇÅ accept
     q‚ÇÄ --a--&gt; q‚ÇÅ
     q‚ÇÅ --b--&gt; q‚ÇÅ

Eliminating: No intermediate states
Final RE: a&centerdot;b*</pre><pre class="hljs"><code>DFA: States {<span class="hljs-selector-tag">q</span>‚ÇÄ, <span class="hljs-selector-tag">q</span>‚ÇÅ}, <span class="hljs-selector-tag">q</span>‚ÇÄ start, <span class="hljs-selector-tag">q</span>‚ÇÅ accept
     <span class="hljs-selector-tag">q</span>‚ÇÄ <span class="hljs-attr">--a--</span>&gt; <span class="hljs-selector-tag">q</span>‚ÇÅ
     <span class="hljs-selector-tag">q</span>‚ÇÅ <span class="hljs-attr">--b--</span>&gt; <span class="hljs-selector-tag">q</span>‚ÇÅ

Eliminating: No intermediate states
Final RE: a&centerdot;b*</code></pre></div>
<hr/>
<h2 id="kleenes-theorem-part-2"><strong>Kleene&apos;s Theorem - Part 2</strong></h2>
<p><strong>Statement:</strong> If a language L is described by a regular expression, then L is accepted by some finite automaton.</p>
<h3 id="bulb-proof-idea-2"><strong>üí° Proof Idea:</strong></h3>
<p>Build NFAs recursively for each regex operation. The beauty is that NFAs naturally handle the non-deterministic choices needed for union and Kleene star, while &epsi;-transitions elegantly connect subautomata.</p>
<h3 id="proof-thompsons-construction"><strong>Proof (Thompson&apos;s Construction):</strong></h3>
<p><strong>Base Cases:</strong></p>
<ol>
<li><strong>&empty;:</strong> NFA with start state, no accept state, no transitions</li>
<li><strong>&epsi;:</strong> NFA with start state = accept state, no transitions</li>
<li><strong>a (symbol):</strong> NFA with start state, accept state, transition start --a--&gt; accept</li>
</ol>
<p><strong>Inductive Cases:</strong></p>
<p><strong>Union (R‚ÇÅ &cup; R‚ÇÇ):</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```
" data-joplin-source-close="
```">    &epsi;     N‚ÇÅ     &epsi;
q‚ÇÄ ---&gt; q‚ÇÅ --- q‚ÇÇ ---&gt; q‚ÇÉ
 |              &epsi;       &ShortUpArrow;
 |      &epsi;     N‚ÇÇ     &epsi; |
 &boxur;----&gt; q‚ÇÑ --- q‚ÇÖ -----&boxul;</pre><pre class="hljs"><code>    <span class="hljs-comment">&epsi;     N‚ÇÅ     &epsi;</span>
<span class="hljs-comment">q‚ÇÄ</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-comment">q‚ÇÅ</span> <span class="hljs-literal">---</span> <span class="hljs-comment">q‚ÇÇ</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-comment">q‚ÇÉ</span>
 <span class="hljs-comment">|              &epsi;       &ShortUpArrow;</span>
 <span class="hljs-comment">|      &epsi;     N‚ÇÇ     &epsi; |</span>
 <span class="hljs-comment">&boxur;</span><span class="hljs-literal">----</span>&gt; <span class="hljs-comment">q‚ÇÑ</span> <span class="hljs-literal">---</span> <span class="hljs-comment">q‚ÇÖ</span> <span class="hljs-literal">-----</span><span class="hljs-comment">&boxul;</span></code></pre></div>
<p><strong>Concatenation (R‚ÇÅ &centerdot; R‚ÇÇ):</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```
" data-joplin-source-close="
```">q‚ÇÄ ---&gt; N‚ÇÅ ---&gt; q‚ÇÅ ---&gt; N‚ÇÇ ---&gt; q‚ÇÇ
              &epsi;</pre><pre class="hljs"><code><span class="hljs-comment">q‚ÇÄ</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-comment">N‚ÇÅ</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-comment">q‚ÇÅ</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-comment">N‚ÇÇ</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-comment">q‚ÇÇ</span>
              <span class="hljs-comment">&epsi;</span></code></pre></div>
<p>*<em>Kleene Star (R‚ÇÅ</em>):**</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```
" data-joplin-source-close="
```">    &epsi;
&boxdr;-------&boxdl;
&darr;       |
q‚ÇÄ ---&gt; q‚ÇÅ ---&gt; N‚ÇÅ ---&gt; q‚ÇÇ ---&gt; q‚ÇÉ
|        &epsi;              &epsi;       &ShortUpArrow;
|                      &epsi;        |
&boxur;------------------------------ &boxul;</pre><pre class="hljs"><code>    <span class="hljs-comment">&epsi;</span>
<span class="hljs-comment">&boxdr;</span><span class="hljs-literal">-------</span><span class="hljs-comment">&boxdl;</span>
<span class="hljs-comment">&darr;       |</span>
<span class="hljs-comment">q‚ÇÄ</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-comment">q‚ÇÅ</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-comment">N‚ÇÅ</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-comment">q‚ÇÇ</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-comment">q‚ÇÉ</span>
<span class="hljs-comment">|        &epsi;              &epsi;       &ShortUpArrow;</span>
<span class="hljs-comment">|                      &epsi;        |</span>
<span class="hljs-comment">&boxur;</span><span class="hljs-literal">------------------------------</span> <span class="hljs-comment">&boxul;</span></code></pre></div>
<p><strong>Properties of Thompson&apos;s Construction:</strong></p>
<ul>
<li>Exactly one start state, one accept state</li>
<li>No transitions into start state</li>
<li>No transitions out of accept state</li>
<li>At most 2&epsi; transitions from any state</li>
</ul>
<hr/>
<h2 id="pumping-lemma-for-regular-languages"><strong>Pumping Lemma for Regular Languages</strong></h2>
<p><strong>Statement:</strong> If L is regular, then &exist;p &gt; 0 such that &forall;w &Element; L with |w| &ge; p, w can be written as w = xyz where:</p>
<ol>
<li>|xy| &le; p</li>
<li>|y| &gt; 0</li>
<li>&forall;i &ge; 0, xy^i z &Element; L</li>
</ol>
<h3 id="bulb-proof-idea-3"><strong>üí° Proof Idea:</strong></h3>
<p>A DFA has finite states, so any long enough string must revisit some state, creating a loop. This loop can be repeated (pumped) or skipped without affecting acceptance.</p>
<h3 id="proof"><strong>Proof:</strong></h3>
<p><strong>Step 1:</strong> Since L is regular, &exist; DFA M = (Q, &Sigma;, &delta;, q‚ÇÄ, F) that accepts L.</p>
<p><strong>Step 2:</strong> Let p = |Q| (number of states in M).</p>
<p><strong>Step 3:</strong> Consider any w &Element; L with |w| &ge; p. Let w = a‚ÇÅa‚ÇÇ...a‚Çô where n &ge; p.</p>
<p><strong>Step 4:</strong> Consider the sequence of states: q‚ÇÄ, &delta;(q‚ÇÄ,a‚ÇÅ), &delta;(q‚ÇÄ,a‚ÇÅa‚ÇÇ), ..., &delta;(q‚ÇÄ,a‚ÇÅ...a‚Çô)</p>
<p><strong>Step 5:</strong> This sequence has n+1 &ge; p+1 &gt; |Q| states.</p>
<p><strong>Step 6:</strong> By Pigeonhole Principle, some state repeats. Let q·µ¢ = q‚±º where 0 &le; i &lt; j &le; p.</p>
<p><strong>Step 7:</strong> Decompose w:</p>
<ul>
<li>x = a‚ÇÅ...a·µ¢ (brings us to q·µ¢)</li>
<li>y = a·µ¢‚Çä‚ÇÅ...a‚±º (loop from q·µ¢ back to q·µ¢)</li>
<li>z = a‚±º‚Çä‚ÇÅ...a‚Çô (continues to accept state)</li>
</ul>
<p><strong>Step 8:</strong> Verify conditions:</p>
<ol>
<li>|xy| = j &le; p &check;</li>
<li>|y| = j - i &gt; 0 &check; (since i &lt; j)</li>
<li>xy^i z &Element; L for all i &ge; 0 &check; (can repeat or skip the loop)</li>
</ol>
<hr/>
<h2 id="pumping-lemma-for-context-free-languages"><strong>Pumping Lemma for Context-Free Languages</strong></h2>
<p><strong>Statement:</strong> If L is context-free, then &exist;p &gt; 0 such that &forall;s &Element; L with |s| &ge; p, s can be written as s = uvwxy where:</p>
<ol>
<li>|vwx| &le; p</li>
<li>|vx| &ge; 1</li>
<li>&forall;i &ge; 0, uv^i wx^i y &Element; L</li>
</ol>
<h3 id="bulb-proof-idea-4"><strong>üí° Proof Idea:</strong></h3>
<p>In a parse tree for a long string, some variable must appear twice on a path from root to leaf (pigeonhole principle). This creates a &quot;nested&quot; structure that can be pumped by repeating the inner pattern.</p>
<h3 id="proof-2"><strong>Proof:</strong></h3>
<p><strong>Step 1:</strong> Since L is CFL, &exist; CFG G = (V, &Sigma;, R, S) in CNF that generates L.</p>
<p><strong>Step 2:</strong> Let p = 2^(|V|+1) where |V| is number of variables.</p>
<p><strong>Step 3:</strong> Consider s &Element; L with |s| &ge; p. Any parse tree for s has height &ge; |V| + 1.</p>
<p><strong>Step 4:</strong> Consider a longest path from root to leaf (length &ge; |V| + 1).</p>
<p><strong>Step 5:</strong> This path has &ge; |V| + 2 nodes, so &ge; |V| + 1 variables.</p>
<p><strong>Step 6:</strong> By Pigeonhole Principle, some variable A repeats on this path.</p>
<p><strong>Step 7:</strong> Choose the lowest repetition of A. Let the tree structure be:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```
" data-joplin-source-close="
```">       S
      / \
     /   \
    u     y
         / \
        /   \
       A     
      /|\    
     / | \   
    v  A  x  
      /|\ 
     / | \
    w</pre><pre class="hljs"><code>       S
      / <span class="hljs-string">\</span>
     /   <span class="hljs-string">\</span>
    u     y
         / <span class="hljs-string">\</span>
        /   <span class="hljs-string">\</span>
       A     
      /|<span class="hljs-string">\</span>    
     / | <span class="hljs-string">\</span>   
    v  A  x  
      /|<span class="hljs-string">\</span> 
     / | <span class="hljs-string">\</span>
    w</code></pre></div>
<p><strong>Step 8:</strong> This gives decomposition s = uvwxy where:</p>
<ul>
<li>u, y: parts outside both A&apos;s</li>
<li>v, x: parts between the two A&apos;s</li>
<li>w: part inside inner A</li>
</ul>
<p><strong>Step 9:</strong> Verify conditions:</p>
<ol>
<li>|vwx| &le; p: The subtree rooted at outer A has yield vwx, and its height is &le; |V| + 1, so |vwx| &le; 2^(|V|+1) = p</li>
<li>|vx| &ge; 1: Since A &rarr; vAx is a production in CNF, at least one of v, x is non-empty</li>
<li>uv^i wx^i y &Element; L: Replace outer A with i copies of the pattern</li>
</ol>
<hr/>
<h2 id="ardens-theorem"><strong>Arden&apos;s Theorem</strong></h2>
<p><strong>Statement:</strong> Let X be a language variable, and let A, B be regular languages with &epsi; &NotElement; A. Then the equation X = AX &cup; B has a unique solution X = A*B.</p>
<h3 id="bulb-proof-idea-5"><strong>üí° Proof Idea:</strong></h3>
<p>This theorem solves &quot;language equations&quot; - it&apos;s like solving X = aX + b in algebra, but for languages. The key insight is that A* captures all possible ways to repeatedly prepend strings from A.</p>
<h3 id="proof-3"><strong>Proof:</strong></h3>
<p><strong>Part 1: X = A*B is a solution</strong></p>
<p>We need to show A<em>B = A(A</em>B) &cup; B.</p>
<p><strong>LHS:</strong> A*B = (&epsi; &cup; A &cup; AA &cup; AAA &cup; ...)B = B &cup; AB &cup; AAB &cup; AAAB &cup; ...</p>
<p><strong>RHS:</strong> A(A*B) &cup; B = A(B &cup; AB &cup; AAB &cup; ...) &cup; B = AB &cup; AAB &cup; AAAB &cup; ... &cup; B = B &cup; AB &cup; AAB &cup; AAAB &cup; ...</p>
<p>Therefore LHS = RHS, so A*B is indeed a solution.</p>
<p><strong>Part 2: Uniqueness</strong></p>
<p>Suppose Y is any solution to X = AX &cup; B. We&apos;ll prove Y = A*B.</p>
<p><strong>Step 1:</strong> From Y = AY &cup; B, we get Y &supe; B.</p>
<p><strong>Step 2:</strong> From Y = AY &cup; B and Y &supe; B, we get: Y = AY &cup; B &supe; AB &cup; B So Y &supe; AB &cup; B.</p>
<p><strong>Step 3:</strong> By induction, Y &supe; A‚ÅøB &cup; A‚Åø‚Åª&sup1;B &cup; ... &cup; AB &cup; B for all n &ge; 0.</p>
<p><strong>Step 4:</strong> Therefore Y &supe; &bigcup;_{n&ge;0} A‚ÅøB = A*B.</p>
<p><strong>Step 5:</strong> Now we prove Y &sube; A*B. Since Y = AY &cup; B, every string in Y is either:</p>
<ul>
<li>In B, hence in A<em>B (since &epsi; &Element; A</em>)</li>
<li>Of form aw where a &Element; A and w &Element; Y</li>
</ul>
<p><strong>Step 6:</strong> By strong induction on string length: If w &Element; Y, then w has form a‚ÇÅa‚ÇÇ...a‚Çñv where a·µ¢ &Element; A, v &Element; B. Since &epsi; &NotElement; A, this process terminates, giving w &Element; A*B.</p>
<p><strong>Therefore Y = A*B.</strong></p>
<h3 id="applications-of-ardens-theorem"><strong>Applications of Arden&apos;s Theorem:</strong></h3>
<p><strong>Converting DFA to Regular Expression (Alternative to State Elimination):</strong></p>
<p>For DFA with states {q‚ÇÅ, q‚ÇÇ, ..., q‚Çô}, create equations:</p>
<ul>
<li>q·µ¢ = &Sigma;_{&delta;(q‚±º,a)=q·µ¢} (q‚±º &centerdot; a) &cup; (&epsi; if q·µ¢ is start state)</li>
</ul>
<p><strong>Example:</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```
" data-joplin-source-close="
```">DFA: q‚ÇÄ --a--&gt; q‚ÇÅ --b--&gt; q‚ÇÅ, q‚ÇÅ is accepting

Equations:
q‚ÇÄ = &epsi;
q‚ÇÅ = q‚ÇÄ&centerdot;a &cup; q‚ÇÅ&centerdot;b

Substituting: q‚ÇÅ = &epsi;&centerdot;a &cup; q‚ÇÅ&centerdot;b = a &cup; q‚ÇÅ&centerdot;b

Using Arden&apos;s theorem (A = b, B = a):
q‚ÇÅ = b*a

Therefore L(DFA) = b*a</pre><pre class="hljs"><code><span class="hljs-symbol">DFA:</span> q‚ÇÄ --a--&gt; q‚ÇÅ --b--&gt; q‚ÇÅ, q‚ÇÅ <span class="hljs-built_in">is</span> accepting

<span class="hljs-symbol">Equations:</span>
q‚ÇÄ = &epsi;
q‚ÇÅ = q‚ÇÄ&centerdot;a &cup; q‚ÇÅ&centerdot;b

<span class="hljs-symbol">Substituting:</span> q‚ÇÅ = &epsi;&centerdot;a &cup; q‚ÇÅ&centerdot;b = a &cup; q‚ÇÅ&centerdot;b

<span class="hljs-keyword">Using</span> Arden<span class="hljs-comment">&apos;s theorem (A = b, B = a):</span>
q‚ÇÅ = b*a

Therefore L(DFA) = b*a</code></pre></div>
<hr/>
<h2 id="theorem-myhill-nerode-theorem-complete-proof"><strong>Theorem: Myhill-Nerode Theorem (Complete Proof)</strong></h2>
<p><strong>Statement:</strong> L is regular iff the equivalence relation &Congruent;_L has finitely many equivalence classes.</p>
<p><strong>Definition:</strong> x &Congruent;_L y iff &forall;z &Element; &Sigma;*, (xz &Element; L &DoubleLongLeftRightArrow; yz &Element; L)</p>
<h3 id="bulb-proof-idea-6"><strong>üí° Proof Idea:</strong></h3>
<p>The equivalence classes of &Congruent;_L naturally correspond to DFA states. If there are finitely many classes, we can build a DFA with one state per class. Conversely, if L is regular, the DFA states bound the number of distinguishable string prefixes.</p>
<h3 id="proof-4"><strong>Proof:</strong></h3>
<p><strong>(&DoubleRightArrow;) If L is regular, then &Congruent;_L has finitely many classes:</strong></p>
<p><strong>Step 1:</strong> Let M = (Q, &Sigma;, &delta;, q‚ÇÄ, F) be DFA accepting L.</p>
<p><strong>Step 2:</strong> Define relation ~: x ~ y iff &delta;*(q‚ÇÄ, x) = &delta;*(q‚ÇÄ, y)</p>
<p><strong>Step 3:</strong> Claim: x ~ y &DoubleLongRightArrow; x &Congruent;_L y</p>
<ul>
<li>Proof: If &delta;*(q‚ÇÄ, x) = &delta;*(q‚ÇÄ, y) = q, then for any z: &delta;*(q‚ÇÄ, xz) = &delta;*(q, z) = &delta;*(q‚ÇÄ, yz)</li>
<li>So xz &Element; L &DoubleLongLeftRightArrow; yz &Element; L</li>
</ul>
<p><strong>Step 4:</strong> Since ~ has |Q| classes and ~ refines &Congruent;_L, &Congruent;_L has &le; |Q| classes.</p>
<p><strong>(&DoubleLeftArrow;) If &Congruent;_L has finitely many classes, then L is regular:</strong></p>
<p><strong>Step 1:</strong> Let {C‚ÇÅ, C‚ÇÇ, ..., C‚Çô} be the equivalence classes of &Congruent;_L.</p>
<p><strong>Step 2:</strong> Construct DFA M = (Q, &Sigma;, &delta;, q‚ÇÄ, F) where:</p>
<ul>
<li>Q = {C‚ÇÅ, C‚ÇÇ, ..., C‚Çô}</li>
<li>q‚ÇÄ = class containing &epsi;</li>
<li>F = {C·µ¢ : some (hence all) strings in C·µ¢ are in L}</li>
<li>&delta;(C·µ¢, a) = class containing wa where w &Element; C·µ¢</li>
</ul>
<p><strong>Step 3:</strong> &delta; is well-defined: If w‚ÇÅ, w‚ÇÇ &Element; C·µ¢, then w‚ÇÅa &Congruent;_L w‚ÇÇa</p>
<p><strong>Step 4:</strong> M accepts L: x &Element; L iff &delta;*(q‚ÇÄ, x) &Element; F by construction.</p>
<hr/>
<h2 id="theorem-cfl-closure-under-union-constructive-proof"><strong>Theorem: CFL Closure Under Union (Constructive Proof)</strong></h2>
<p><strong>Statement:</strong> If L‚ÇÅ and L‚ÇÇ are context-free, then L‚ÇÅ &cup; L‚ÇÇ is context-free.</p>
<h3 id="bulb-proof-idea-7"><strong>üí° Proof Idea:</strong></h3>
<p>Create a new grammar that can generate strings from either original grammar by adding a new start symbol with productions that &quot;choose&quot; between the two languages.</p>
<h3 id="proof-5"><strong>Proof:</strong></h3>
<p><strong>Step 1:</strong> Let G‚ÇÅ = (V‚ÇÅ, &Sigma;‚ÇÅ, R‚ÇÅ, S‚ÇÅ) generate L‚ÇÅ and G‚ÇÇ = (V‚ÇÇ, &Sigma;‚ÇÇ, R‚ÇÇ, S‚ÇÇ) generate L‚ÇÇ.</p>
<p><strong>Step 2:</strong> WLOG, assume V‚ÇÅ &cap; V‚ÇÇ = &empty; (rename variables if necessary).</p>
<p><strong>Step 3:</strong> Construct G = (V, &Sigma;, R, S) where:</p>
<ul>
<li>V = V‚ÇÅ &cup; V‚ÇÇ &cup; {S} (S is new start symbol)</li>
<li>&Sigma; = &Sigma;‚ÇÅ &cup; &Sigma;‚ÇÇ</li>
<li>R = R‚ÇÅ &cup; R‚ÇÇ &cup; {S &rarr; S‚ÇÅ, S &rarr; S‚ÇÇ}</li>
</ul>
<p><strong>Step 4:</strong> Prove L(G) = L‚ÇÅ &cup; L‚ÇÇ:</p>
<p><strong>&sube;:</strong> If w &Element; L(G), then S &DoubleRightArrow;* w. The derivation starts S &rarr; S‚ÇÅ or S &rarr; S‚ÇÇ.</p>
<ul>
<li>If S &rarr; S‚ÇÅ, then S‚ÇÅ &DoubleRightArrow;* w using only R‚ÇÅ, so w &Element; L‚ÇÅ</li>
<li>If S &rarr; S‚ÇÇ, then S‚ÇÇ &DoubleRightArrow;* w using only R‚ÇÇ, so w &Element; L‚ÇÇ</li>
<li>Therefore w &Element; L‚ÇÅ &cup; L‚ÇÇ</li>
</ul>
<p><strong>&supe;:</strong> If w &Element; L‚ÇÅ &cup; L‚ÇÇ:</p>
<ul>
<li>If w &Element; L‚ÇÅ, then S‚ÇÅ &DoubleRightArrow;* w, so S &rarr; S‚ÇÅ &DoubleRightArrow;* w</li>
<li>If w &Element; L‚ÇÇ, then S‚ÇÇ &DoubleRightArrow;* w, so S &rarr; S‚ÇÇ &DoubleRightArrow;* w</li>
<li>Therefore w &Element; L(G)</li>
</ul>
<hr/>
<h2 id="theorem-equivalence-of-multi-tape-and-single-tape-tms"><strong>Theorem: Equivalence of Multi-tape and Single-tape TMs</strong></h2>
<p><strong>Statement:</strong> Every k-tape Turing Machine can be simulated by a single-tape Turing Machine.</p>
<h3 id="bulb-proof-idea-8"><strong>üí° Proof Idea:</strong></h3>
<p>Encode multiple tapes on a single tape by interleaving symbols and using markers to track head positions. Each multi-tape step requires scanning the entire single tape twice - once to read current symbols, once to update them.</p>
<h3 id="proof-construction"><strong>Proof (Construction):</strong></h3>
<p><strong>Step 1:</strong> <strong>Encoding Multiple Tapes on Single Tape</strong></p>
<ul>
<li>Use tape alphabet &Gamma;&apos; = (&Gamma; &cup; {#})^k &times; {0,1}^k</li>
<li>Each cell stores k symbols and k bits (indicating head positions)</li>
<li>Separate tape contents with # symbols</li>
</ul>
<p><strong>Step 2:</strong> <strong>Initial Configuration</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```
" data-joplin-source-close="
```">Original k tapes:    |a|b|c| &square; &square; ...
                     |d|e| &square; &square; &square; ...
                     
Single tape:    #(a,d,1,1)#(b,e,0,0)#(c,&square;,0,0)#(&square;,&square;,0,0)#...</pre><pre class="hljs"><code>Original k tapes:    |a|b|c| &square; &square; ...
                     |d|e| &square; &square; &square; ...
                     
Single tape:    <span class="hljs-punctuation">#</span><span class="hljs-params">(<span class="hljs-variable">a</span>,<span class="hljs-variable">d</span>,1,1)</span><span class="hljs-punctuation">#</span><span class="hljs-params">(<span class="hljs-variable">b</span>,<span class="hljs-variable">e</span>,0,0)</span><span class="hljs-punctuation">#</span><span class="hljs-params">(<span class="hljs-variable">c</span>,&square;,0,0)</span><span class="hljs-punctuation">#</span><span class="hljs-params">(&square;,&square;,0,0)</span><span class="hljs-punctuation">#</span>...</code></pre></div>
<p><strong>Step 3:</strong> <strong>Simulation of One Step</strong> For each transition &delta;(q, a‚ÇÅ,...,a‚Çñ) = (q&apos;, b‚ÇÅ,...,b‚Çñ, D‚ÇÅ,...,D‚Çñ):</p>
<ol>
<li><strong>Scan Phase:</strong> Scan entire tape to find head positions and read symbols</li>
<li><strong>Update Phase:</strong> Scan again to:
<ul>
<li>Write new symbols b‚ÇÅ,...,b‚Çñ at head positions</li>
<li>Update head position markers according to D‚ÇÅ,...,D‚Çñ</li>
<li>If head moves right past end, extend tape</li>
</ul>
</li>
</ol>
<p><strong>Step 4:</strong> <strong>Time Complexity Analysis</strong></p>
<ul>
<li>If k-tape TM runs in time T(n), single-tape simulation takes O(T(n)&sup2;)</li>
<li>Each step requires 2 full scans of length O(T(n))</li>
</ul>
<p><strong>Step 5:</strong> <strong>Correctness</strong></p>
<ul>
<li>Initial configuration correctly represents k blank tapes</li>
<li>Each simulation step correctly implements one k-tape step</li>
<li>Acceptance condition preserved</li>
</ul>
<hr/>
<h2 id="theorem-undecidability-of-the-halting-problem"><strong>Theorem: Undecidability of the Halting Problem</strong></h2>
<p><strong>Statement:</strong> The language H = {&lang;M,w&rang; | M is a TM that halts on input w} is undecidable.</p>
<h3 id="bulb-proof-idea-9"><strong>üí° Proof Idea:</strong></h3>
<p>Create a paradox using self-reference. If we could decide halting, we could build a machine that does the opposite of what our halting decider predicts when run on itself - a logical contradiction.</p>
<h3 id="proof-diagonalization"><strong>Proof (Diagonalization):</strong></h3>
<p><strong>Assume for contradiction</strong> that H is decidable. Then &exist; TM D that decides H:</p>
<ul>
<li>D(&lang;M,w&rang;) = accept if M halts on w</li>
<li>D(&lang;M,w&rang;) = reject if M doesn&apos;t halt on w</li>
</ul>
<p><strong>Step 1:</strong> Construct TM H&apos; that behaves as follows on input &lang;M&rang;:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```
" data-joplin-source-close="
```">H&apos;(&lang;M&rang;):
1. Run D(&lang;M,&lang;M&rang;&rang;)
2. If D accepts: loop forever
3. If D rejects: halt and accept</pre><pre class="hljs"><code>H&apos;(&lang;M&rang;):
<span class="hljs-bullet">1.</span> Run D(&lang;M,&lang;M&rang;&rang;)
<span class="hljs-bullet">2.</span> If D accepts: loop forever
<span class="hljs-bullet">3.</span> If D rejects: halt and accept</code></pre></div>
<p><strong>Step 2:</strong> What happens when we run H&apos; on its own encoding &lang;H&apos;&rang;?</p>
<p><strong>Case 1:</strong> Suppose H&apos; halts on &lang;H&apos;&rang;</p>
<ul>
<li>Then D(&lang;H&apos;,&lang;H&apos;&rang;&rang;) should accept (since H&apos; halts on &lang;H&apos;&rang;)</li>
<li>But then H&apos; loops forever by its definition</li>
<li>Contradiction!</li>
</ul>
<p><strong>Case 2:</strong> Suppose H&apos; doesn&apos;t halt on &lang;H&apos;&rang;</p>
<ul>
<li>Then D(&lang;H&apos;,&lang;H&apos;&rang;&rang;) should reject (since H&apos; doesn&apos;t halt on &lang;H&apos;&rang;)</li>
<li>But then H&apos; halts and accepts by its definition</li>
<li>Contradiction!</li>
</ul>
<p><strong>Step 3:</strong> Since both cases lead to contradiction, our assumption is false. Therefore, H is undecidable.</p>
<hr/>
<h2 id="theorem-rices-theorem"><strong>Theorem: Rice&apos;s Theorem</strong></h2>
<p><strong>Statement:</strong> Let P be any non-trivial property of recursively enumerable languages. Then {&lang;M&rang; | L(M) has property P} is undecidable.</p>
<p><strong>Definition:</strong> Property P is non-trivial if:</p>
<ul>
<li>Some r.e. language has property P</li>
<li>Some r.e. language doesn&apos;t have property P</li>
</ul>
<h3 id="bulb-proof-idea-10"><strong>üí° Proof Idea:</strong></h3>
<p>Use the Halting Problem as a &quot;universal reducer.&quot; For any semantic property P, we can construct machines whose language depends on whether a given machine halts - effectively reducing the Halting Problem to property P.</p>
<h3 id="proof-6"><strong>Proof:</strong></h3>
<p><strong>Step 1:</strong> WLOG, assume &empty; doesn&apos;t have property P (if it does, consider PÃÑ).</p>
<p><strong>Step 2:</strong> Since P is non-trivial, &exist; language L‚ÇÄ that has property P. Let M‚ÇÄ be a TM with L(M‚ÇÄ) = L‚ÇÄ.</p>
<p><strong>Step 3:</strong> <strong>Assume for contradiction</strong> that S_P = {&lang;M&rang; | L(M) has property P} is decidable.</p>
<p><strong>Step 4:</strong> We&apos;ll use this to decide the Halting Problem, contradicting its undecidability.</p>
<p><strong>Step 5:</strong> <strong>Construction:</strong> For any &lang;M,w&rang;, construct TM M_{M,w} as follows:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```
" data-joplin-source-close="
```">M_{M,w}(x):
1. Simulate M on input w for |x| steps
2. If M halts within |x| steps: simulate M‚ÇÄ on input x
3. If M doesn&apos;t halt within |x| steps: reject</pre><pre class="hljs"><code>M_{M,w}(x):
<span class="hljs-number">1.</span> Simulate M on input w <span class="hljs-keyword">for</span> |<span class="hljs-type">x</span>| <span class="hljs-type">steps</span>
<span class="hljs-number">2.</span> <span class="hljs-keyword">If</span> M halts within |<span class="hljs-type">x</span>| <span class="hljs-type">steps</span>: simulate M‚ÇÄ on input x
<span class="hljs-number">3.</span> <span class="hljs-keyword">If</span> M doesn&apos;t halt within |<span class="hljs-type">x</span>| <span class="hljs-type">steps</span>: reject</code></pre></div>
<p><strong>Step 6:</strong> <strong>Key Observation:</strong></p>
<ul>
<li>If M halts on w: M_{M,w} eventually simulates M‚ÇÄ on all inputs, so L(M_{M,w}) = L‚ÇÄ</li>
<li>If M doesn&apos;t halt on w: M_{M,w} rejects all inputs, so L(M_{M,w}) = &empty;</li>
</ul>
<p><strong>Step 7:</strong> <strong>Reduction:</strong> Since L‚ÇÄ has property P and &empty; doesn&apos;t:</p>
<ul>
<li>&lang;M,w&rang; &Element; H &DoubleLongLeftRightArrow; L(M_{M,w}) has property P &DoubleLongLeftRightArrow; &lang;M_{M,w}&rang; &Element; S_P</li>
</ul>
<p><strong>Step 8:</strong> If S_P were decidable, we could decide H:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```
" data-joplin-source-close="
```">Algorithm for H:
Input: &lang;M,w&rang;
1. Construct M_{M,w}
2. Test if &lang;M_{M,w}&rang; &Element; S_P
3. Return same answer</pre><pre class="hljs"><code>Algorithm for H:
Input: &lang;M,w&rang;
<span class="hljs-number">1</span>. Construct M_{M,w}
<span class="hljs-number">2</span>. <span class="hljs-keyword">Test</span> <span class="hljs-keyword">if</span> &lang;M_{M,w}&rang; &Element; S_P
<span class="hljs-number">3</span>. <span class="hljs-keyword">Return</span> same answer</code></pre></div>
<p><strong>Step 9:</strong> This contradicts undecidability of H, so S_P is undecidable.</p>
</div></div>
					</body>
				</html>
			